{"data":{"allMdx":{"edges":[{"node":{"fields":{"slug":"/blog/reshaping_git_history/"},"id":"fe3090a8-7396-5843-86d2-da27e79a0948","frontmatter":{"title":"Reshaping Git History","date":"April 24, 2019"},"body":"\n\n## Rebase to the occasion\n\nIt's all too familiar - you start working on some feature locally, you've made several commits, it's almost completed. But suddenly requirements change (happens once in a blue moon, right?), and you have to introduce changes. You tack new commits onto the existing chain. But what if you wanted to unite related changes in an effort to improve readability, portability and clarity before sharing your work with others?\n\nOr consider the following situation. Idea sparks in your mind and you get down to implementing it. In the heat of development, you run up several crude commits in a short succession. You usually strive to keep it focused, but your hands were on fire, you didn't want to be bogged down so you temporarily turned a blind eye on formalities. How do you put things in order now that the sudden drive has subsided?\n\nAnother common scenario is back and forth during PR's review rounds. There could be several takes before you get it right. Once the review is over, it's time to stick changes produced on the fly where they initially belong.\n\nGit grants plenty of freedom when a need to revise local history arises. Commits could be rearranged, altered, split apart, squashed together or wiped out entirely. Surprisingly enough, there is no dedicated tool for modifying history directly! `git commit --amend` might come to your mind as it helps with altering the most recent commit. However, if you need to reach deeper into history, you've got to resort to interactive rebase - the trick is to take a series of commits and rebase them onto their original HEAD instead of another one.\n\nI personally like my commit history to come across as neat and polished, clearly showcasing what has been accomplished. But in this post I'm not going to dig into why maintaining clean history is beneficial. It's rather meant as a practical overview of several `git rebase --interactive` actions allowing for history grooming. Suffice to say it especially makes sense in collaboration environment. When working on some local project which isn't destined to see the light of the day you might not really care how its history looks.\n\n\n## Turn up the bass and rebase\n\n`git rebase --interactive` command is a robust way to mould commit history. It offers more than ten various actions and rather helpfully all of them, along with succinct explanations, are always outlined below the list of commits which are being rebased. For our purposes, we'll be considering the following subset:\n\n* `edit` - allows for amending commit in question;\n* `squash` - combine commit at hand with the one directly above and choose which commit message to use;\n* `fixup` - has the same effect as `squash`, but uses target commit's log message;\n* `drop` - erase commit.\n\nTo actually kick off the process we need to supply an SHA hash of the commit which comes right before the point where we'd like to start rebasing (`-i` is a shorthand for `--interactive`):\n\n```bash\ngit rebase -i <after_this_commit>\n```\n\nYou don't have to always indicate hash. Tip of the branch (aka HEAD pointer) could be used as a reference instead. Let's stick with the last three commits:\n\n```bash\ngit rebase -i HEAD~3\n```\n\nAs a result, Git opens up an editor within the terminal window and presents a list of selected records which will resemble the following:\n\n```bash\npick a1rt1m3 third-to-last commit summary\npick bass1st second-to-last commit summary\npick cr0wbar last commit summary\n```\n\nCompared to `git log`'s output, the chronological order is reversed - the oldest change appears at the top here. If we just save the buffer without touching anything, Git will follow the listing downward and execute actions sequentially. `pick` is the default one indicating our intention to keep the commit. If we wanted to manipulate any of the records, we'd replace `pick` with desired action.\n\n\n### Editing\n\n```bash\npick a1rt1m3 third-to-last commit summary\nedit bass1st second-to-last commit summary\npick cr0wbar last commit summary\n```\n\nIn this scenario, when Git reaches `bass1st`, it will pause and give you an opportunity to introduce changes. Once done, toss edits into the staging area, invoke `git commit --amend` to fold them in and resume the process using `git rebase --continue`.\n\nSometimes it might make sense to split one large commit apart. In order to achieve that, unstage all associated files via `git reset HEAD~` (which effectively undoes the commit) and form tinier commits as required.\n\nIt's worth noting that when Git stops and gives you a chance to edit a commit you'll find yourself in so called [detached HEAD state](https://git-scm.com/docs/git-checkout#_detached_head). It usually implies that all new commits will be lost unless you create an explicit reference (new branch or tag) as garbage collector routinely removes non-referenced objects. However, you don't have to worry about that while rebasing since Git already knows that we'd like to retain any changes as part of the process.\n\nFinally, if you misstepped and things got messed up - don't fret! It's always possible to cancel an ongoing rebase and restore everything to the prior state by executing `git rebase --abort`.\n\n\n### Squashing and fixups\n\nSay we committed something which fundamentally belongs to the existing `a1rt1m3` commit:\n\n```bash\npick a1rt1m3 third-to-last commit summary\npick bass1st second-to-last commit summary\npick cr0wbar last commit summary\npick jazz13r new changes\n```\n\nThere are two options to meld `jazz13r` into `a1rt1m3`. First would be `squash`, which allows for choosing which commit message to apply in the end. Second one would be `fixup`, which acts identically but doesn't let you pick and uses target commit's message instead.\n\nWith any of these commands, however, the general idea is to place accessary commit (or commits) right below the target commit:\n\n```bash\npick a1rt1m3 third-to-last commit summary\nfixup jazz13r new changes\npick bass1st second-to-last commit summary\npick cr0wbar last commit summary\n```\n\nPicking an action and reordering actually could be done automatically. Start with committing new changes using [one of the special flags](https://git-scm.com/docs/git-commit#Documentation/git-commit.txt---fixupltcommitgt) and specifying the target:\n\n```bash\ngit commit --squash (or --fixup) <commit_to_modify>\n```\n\nWhich translates to following, in line with our example:\n\n```bash\ngit commit --fixup a1rt1m3\n```\n\nYou'll notice that the subject line will contain target commit's message prefixed with the action we defined earlier:\n\n```bash\npick a1rt1m3 third-to-last commit summary\npick bass1st second-to-last commit summary\npick cr0wbar last commit summary\npick jazz13r fixup! third-to-last commit summary\n```\n\nStart rebasing with an additional flag called ['autosquash'](https://git-scm.com/docs/git-rebase#Documentation/git-rebase.txt---autosquash):\n\n```bash\ngit rebase -i --autosquash HEAD~4\n```\n\nGit will pre-scan records and rearrange the list for you. Hey presto!\n\n```bash\npick a1rt1m3 third-to-last commit summary\nfixup jazz13r fixup! third-to-last commit summary\npick bass1st second-to-last commit summary\npick cr0wbar last commit summary\n```\n\n### Deleting\n\nDeletion is trivial. Either apply `drop` action, or simply erase the line.\n\n\n### Reordering\n\nSwitching order of the items is also a no-brainer. Simply rearrange the lines as necessary:\n\n```bash\npick bass1st second-to-last commit summary\npick cr0wbar last commit summary\npick a1rt1m3 third-to-last commit summary\n```\n\n## Proceed with caution\nRebasing (or any other method of rewriting for that matter) a branch which others have used as a basis for their work is a terrible idea. It will likely cause major nuisance and provoke issues. Even if you haven't changed anything during rebase, every commit touched by the process will have its hash recalculated and everyone downstream at the very least will be forced to refetch in order to avoid complications. [In the worst case](https://git-scm.com/docs/git-rebase#_the_hard_case), they'll have to manually fix their history and this is by no means an enjoyable pastime. Bottom line - never ever tamper shared work history and only push your commits to the remote when you are truly happy with the result.\n"}},{"node":{"fields":{"slug":"/blog/better_backup/"},"id":"c5e3c53a-14aa-5682-9166-11d1ab23b448","frontmatter":{"title":"A Better Backup Plan","date":"January 30, 2019"},"body":"\nThings do not always go as planned - future has a tendency to surprise in many unexpected ways. While accounting for every possible outcome is simply beyond human abilities, it's no reason to skip on planning and let things slide. Having a fallback option is vital as it eliminates fear of failure which severely bogs down and, in worst cases, kills aspirations.\n\nOn the other hand, conceiving an alternative might stifle your performance and hinder your potential. There is a safety net out there, and you subconsciously pull your sleeves down. This might indeed prevent you to execute at the highest level of your abilities in order to achieve set goals. While this sounds reasonable, the truth is that not everyone can transform their fear of failure into motivation - and fear can be absolutely paralysing when stakes are high enough. Moreover, persisting against all odds is rather an exception and, in fairness, not the most efficient approach considering the pace of change nowadays. No doubt you've got to stick to your guns, but at the same time you want to be fluid, able to adapt and evolve along with your environment.\n\nI think you don't have to mutually exclude these approaches. Instead, pick the best parts and fruitfully combine them. You can still commit completely to your initial objective as if there was no tomorrow even with few fallback options already schemed. It requires sort of a mind trick, though. You've got to stash these backups away and put a lid on them. Carry through with all your energy focused on accomplishing target goals. At the same time, be mindful and perform reality checks. When you realize there is a high probability that it won't pan out, switch to the next plan in chain and indulge in it with the same rigor. Remember - there is always a risk of falling victim to sunken cost fallacy instead of being smart about your next move.\n\nSpeaking of plan composition, at the very least you'll need plan B. It might not\nbe as ambitious as plan A, however keep these two as close as possible in scope.\nPlan Z won't hurt either. That's your insurance, a course of action when everything falls through. Force majeure is real and you'd better be ready when the world comes crashing down.\n"}},{"node":{"fields":{"slug":"/blog/deep_work/"},"id":"04e31957-1a78-57c5-81be-8be5e49a1eb8","frontmatter":{"title":"Deep Work","date":"January 09, 2019"},"body":"\nLet's face it - it's extremely hard to keep your mind at some particular target for prolonged stretch of time without getting your attention diverted. Even if you take measures to protect yourself - by retreating to some hushed place, for instance - the mind keeps racing, only just you are being distracted from within.\n\nThis might not be an issue for the majority of people - after all, our life is comprised of many activities which have to be done swiftly and it's not necessary at all to ponder at some task you've done million times before. Yet for someone who is tackling a complicated problem or trying to learn a difficult topic, distraction is costly - getting back on track isn't something you can do by snapping your fingers. I certainly wish I could take a snapshot of everything in my mind before talking to someone and then immediately roll myself back into it after the conversation is over.\n\nAttention is akin to a muscle in a sense that it could be built. The stronger it is, the longer is your ability to focus. The longer you can maintain focus, the more quality progress you can make in whatever activity you are engaged. Powering through a tough spot in a problem or task at hand instead of backing down (which is an innate response for the majority of us) might be one of the best exercises out there. You are unlikely to arrive at a solution straight away as it usually starts to click after few intermittent attacks - but that definitely pumps the focus muscle a lot.\n\nThe ability to maintain strong focus opens up a lot of opportunities for both personal and professional development and more often than not unlocks useful insights. Undivided attention is one of your most valuable assets. Nurture it, guard it. And as with any scarce resource, spend wisely.\n"}}]}}}